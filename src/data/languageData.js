const CONTROL_KEYWORDS = new Set([
  'if',
  'elseif',
  'else',
  'endif',
  'while',
  'done',
  'break',
  'subroutine',
  'endsubroutine',
  'gosub',
  'returnsub',
  'end'
]);

const CONTROL_KEYWORD_DOCS = {
  if: 'Conditional if statement. The format is `if value1 condition value2`, where `value1` and `value2` are number or string variables and condition is the comparison to be made. The values can be actual numbers (or strings) or variables. If using an actual string (word), do not use quotes, and there cannot be spaces in the string. To compare strings with spaces in them you must set and compare string variables. Complex statements are not allowed (more than one condition). Math is also not allowed within the statement. Multiple `if` statements can be nested. Each `if` statement must be ended with the `endif` command. Everything in between the `if` and `endif` is executed if the condition is true.',
  elseif: 'Conditional statement to be processed when the `if` or preceding `elseif` statements are false. The format is the same as the `if` statement.',
  else: 'Fallback branch when `if` and all `elseif` conditions are false.',
  endif: 'Closes an `if` block.',
  while: 'Conditional loop. The format is the same as the `if` command. The `while` command must be ended with the `done` command. If the `while` condition is true then the code between the `while` and `done` commands is executed. When the `done` command is reached, the `while` condition is checked again to see if it is true or false. When the condition is false the code continues on after the `done` command, otherwise it loops back to the beginning of the `while` command.',
  done: 'Closes a `while` loop block.',
  break: 'Breaks out of the current `while` command. The is meant to be used with conditional statements, to be able to exit the loop without having to get all the way to the `done` command, or to exit when the condition is still true.',
  subroutine: 'Marks the start of a subroutine. The format is `subroutine name`, where name is the name of the subroutine. The subroutine must be ended with the `endsubroutine` command.',
  endsubroutine: 'Closes a `subroutine` block.',
  gosub: 'Calls a subroutine. The format is `gosub name`, where name is the name of the subroutine. When the subroutine ends by either the `endsubroutine` or `returnsub` command, program execution will resume on the line following the `gosub` command.',
  returnsub: 'Returns from the current subroutine. This is meant to be used with conditional statements, to be able to exit the subroutine before reaching the `endsubroutine` command.',
  end: 'The script will terminate with a normal exit code of 0.'
};

const COMMANDS = new Set([
  'echo',
  'seti',
  'sets',
  'exit',
  'hex',
  'decimal',
  'printbuffer',
  'stringtobuffer',
  'clearbuffer',
  'buffersize',
  'writebuffer',
  'readbuffer',
  'direction',
  'scsi6cmd',
  'scsi10cmd',
  'scsi12cmd',
  'printsensebuffer',
  'setreadpio',
  'setwritepio',
  'setreaddma',
  'setwritedma',
  'ata28cmd',
  'ata48cmd',
  'writelog',
  'setbuffer',
  'endbuffer',
  'scratchpadsize',
  'writescratchpad',
  'readscratchpad',
  'copyscratchpadtobuffer',
  'copybuffertoscratchpad',
  'printscratchpad',
  'setscratchpad',
  'endscratchpad',
  'stringtoscratchpad',
  'clearscratchpad',
  'variablecheck',
  'getfilesize',
  'deletefile',
  'callcommand',
  'userinput',
  'wordflipbuffer',
  'wordflipscratchpad',
  'getstatus',
  'softreset',
  'usleep',
  'softtimeout',
  'resettimeout',
  'busytimeout',
  'generaltimeout',
  'hardtimeout',
  'gettime',
  'reopendisk',
  'include',
  'loadscript',
  'previousscript',
  'upline'
]);

const INCLUDE_COMMANDS = new Set(['include', 'loadscript']);

const BUILTIN_VARIABLE_DOCS = {
  error_level: 'Some commands return command-specific data in this variable.',
  io_sense_key: 'Sense key (part of the key code qualifier). Passthrough only.',
  io_asc: 'Additional sense code (part of the key code qualifier). Passthrough only.',
  io_ascq: 'Additional sense code qualifier (part of the key code qualifier). Passthrough only.',
  io_status: 'SCSI status byte as defined by the SCSI standard. Passthrough only.',
  io_masked_status: 'SCSI generic masked status. Passthrough only.',
  io_msg_status: 'SCSI generic message status. Passthrough only.',
  io_sb_len_wr: 'Number of bytes in the sense buffer. Passthrough only.',
  io_host_status: 'SCSI generic host status. Passthrough only.',
  io_driver_status: 'SCSI generic driver status. Passthrough only.',
  io_resid: 'SCSI generic residual count. Passthrough only.',
  io_duration: 'Number of milliseconds the SCSI command took to complete. Passthrough only.',
  io_info: 'SCSI generic info field. Passthrough only.',
  ata_return_error: 'ATA error register data.',
  ata_return_count: 'ATA count register data.',
  ata_return_lba: 'ATA LBA register data combined into one value.',
  ata_return_device: 'ATA device register data.',
  ata_return_status: 'ATA status register data.',
  time: 'Value returned from the gettime command.',
  date: 'Value returned from the gettime command.',
  data_transferred: 'Returns number of bytes transferred (indication only, not a guarantee).',
  bus_master_status: 'Bus master status (direct mode DMA commands only).',
  direct_mode: 'Returns 1 if using direct mode, 0 if using passthrough mode.',
  ahci_mode: 'Returns 1 if using AHCI, 0 if using passthrough mode.'
};

const CONSTANT_DOCS = {
  buffer: 'Literal that refers to the main data buffer.',
  scratchpad: 'Literal that refers to the scratchpad buffer.',
  sensebuffer: 'Literal that refers to the SCSI sense buffer.',
  from: 'Data transfer direction literal: from device to host.',
  to: 'Data transfer direction literal: to device from host.',
  tofrom: 'Data transfer direction literal: bidirectional transfer.',
  none: 'Data transfer direction literal: no data transfer.',
  b: 'Byte width literal (8-bit).',
  w: 'Word width literal (16-bit).',
  dw: 'Double-word width literal (32-bit).',
  qw: 'Quad-word width literal (64-bit).'
};

const BUILTIN_FUNCTION_DOCS = {
  echo: 'Print to screen. Text can be output using quotes, either single or double. Quotes of the opposite type inside the original quotes will be output to the screen. Both string and number variables can be output. There must be a space between quotes and variables. Variables must be outside the quotes.',
  seti: 'Set a number variable. All variables must start with `$`. All number variables are integers of type long long (`-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807`).',
  sets: 'Set a string variable. All variables must start with `$`.  The format is similar to the `echo` command, except instead of screen output the string ends up in the variable.',
  exit: 'The script will terminate with an exit code. The format is `exit number`, where number is a value from 0-255. Note that the program already uses some of the lower numbers for program error codes, so it is advised you use numbers 16-255.',
  hex: 'This forces many commands to default to processing numbers as hex instead of decimal. It will affect the output of the `echo` command and also the `sets` command. Be very careful using the `hex` command, as it can cause undesired results if left turned on. It is recommended to only use it before a command such as `echo` to get the desired results from the command, and then use the `decimal` command to turn it back off.',
  decimal: 'This turns off the `hex` command and puts the default number processing back to decimal. It does not force numbers to be processed as decimal, if they are proceeded by `0x` they are still processed as hex.',
  printbuffer: 'Prints the buffer to the screen. The format is `printbuffer offset size`, where offset is the starting buffer offset, and size is the number of bytes to be printed. You cannot print past the end of the current buffer size.',
  stringtobuffer: 'Puts a string into the buffer contents. The format is `stringtobuffer offset size $string`, where offset is the buffer offset, size is the maximum copy size, and `$string` is the string variable name. If size is greater than the length of the string then the whole string will be copied into the buffer, and the copy will stop at the end of the string. If size is smaller than the length of the string then it will only copy up to the size limit and the rest of the string is ignored.',
  clearbuffer: 'Clears (erases) the entire buffer contents to zero.',
  buffersize: 'Sets a new buffer size. This erases (destroys) the current buffer contents. The format is `buffersize size`, where size is the new size of the buffer in bytes. The default starting buffer size is `512`. The maximum buffer size is `33554432 (512 x 65536)`.',
  writebuffer: 'Write the buffer or part of the buffer to a file. The format is `writebuffer filename bufferoffset fileoffset size`, where filename is the name of the file to write to, bufferoffset is the byte offset of the starting point in the buffer, fileoffset is the byte offset of the write point in the file, and size is the size in bytes to be written. If the file does not exist it will be created. This will overwrite the designated data in the file, but will not erase any other data in the file, meaning you can keep adding data to the file at different offsets.',
  readbuffer: 'Read a part of a file to the buffer. The format is `readbuffer filename bufferoffset fileoffset size`, where filename is the name of the file to read from, bufferoffset is the byte offset of the starting point in the buffer, fileoffset is the byte offset of the read point in the file, and size is the size in bytes to be read.',
  direction: 'Set the direction of the data transfer to either `none`, `to`, `from`, or `tofrom`. This is often required for proper processing of both SCSI and ATA passthrough commands by the Linux kernel. The proper direction needed for a command can be found in the SCSI or ATA documentation respectively. Note that for ATA commands this is set by the `setreadpio`, `setreaddma`, `setwritepio`, and `setwritedma` commands respectively, so you do not need to set it directly. You do need to set it with SCSI commands.',
  scsi6cmd: 'Perform a SCSI 6 command. Format is `scsi6cmd b0 b1 b2 b3 b4 b5`, where `b0`-`b5` are the actual bytes of the command.',
  scsi10cmd: 'Perform a SCSI 10 command. Format is `scsi10cmd b0 b1 b2 b3 b4 b5 b6 b7 b8 b9`, where `b0`-`b9` are the actual bytes of the command.',
  scsi12cmd: 'Perform a SCSI 12 command. Format is `scsi12cmd b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15`, where `b0`-`b15` are the actual bytes of the command.',
  printsensebuffer: 'Prints the SCSI return sense buffer to the screen. The format is `printsensebuffer offset size`, where offset is the sense buffer offset, and size is the number of bytes to be printed. The maximum sense buffer size is 256.',
  setreadpio: 'Prepare for PIO read. Required before performing this type of ATA command. If the buffer size is set to zero prior to this command, then it will setup for a non-data command. If you wish to perform a non-data command you should set the buffer size to zero before performing this command.',
  setwritepio: 'Prepare for PIO write. Required before performing this type of ATA command. If the buffer size is set to zero prior to this command, then it will setup for a non-data command. If you wish to perform a non-data command you should set the buffer size to zero before performing this command. The non-data command is the same as when performing a non-data `setreadpio` command.',
  setreaddma: 'Prepare for DMA read. Required before performing this type of ATA command.',
  setwritedma: 'Prepare for DMA write. Required before performing this type of ATA command.',
  ata28cmd: 'ATA 28 bit command. The format is `ata28cmd b0 b1 b2 b3 b4 b5 b6`, where `b0`-`b6` are the actual bytes of the command according to ATA documentation. Note that the device bit of the device field will be set for you according to the device being accessed, in either passthrough or direct IO modes.',
  ata48cmd: 'ATA 48 bit command. The format is `ata48cmd w0 w1 w2 w3 w4 b5 b6`, where `w0`-`w4` are the actual words of the command according to ATA documentation, and `b5`-`b6` are the device and commands bytes. The words are in standard format and not flipped (not little endian), meaning that `0x0001` has a value of `1`. Note that the device bit of the device field will be set for you according to the device being accessed, in either passthrough or direct IO modes, so it does not matter what value you give that bit. Also remember that the LBA order is reversed from the 28 bit command.',
  writelog: 'Write a string variable to a text file as a line. This will append the string to the end of the existing file. The format is `writelog filename string`, where filename is the name of the file to be written to, and string is the variable to be written. If the file does not exist it will be created.',
  setbuffer: 'Manually set the buffer contents. The buffer contains the data that is either sent to or received from the drive. The format is `setbuffer offset`, where offset is a number (can be a variable) that is the location in the buffer to start. The lines following the `setbuffer` command are the actual data, to be ended by the `endbuffer` command. The data must be in the format of byte- space-byte-space-byte, and the data is always processed as hex. There is no set number of bytes per row, the next row will just pick up where the last row left off. A row can start with an additional offset (which will be an additional offset to the supplied buffer offset). To use the additional offset start the line with a hex number followed by a colon.',
  endbuffer: 'Ends multi-line setbuffer input mode.',
  scratchpadsize: 'Sets a new scratchpad size. The format and use is the same as the `buffersize` command.',
  writescratchpad: 'Write the scratchpad to a file. The format and use is the same as the `writebuffer` command.',
  readscratchpad: 'Read a part of a file to the scratchpad. The format and use is the same as the `readbuffer` command.',
  copyscratchpadtobuffer: 'Copies a part of the scatchpad to the buffer. The format is `copyscratchpadtobuffer scratchoffset bufferoffset size`, where scratchoffset is the starting offset of the scratchpad, bufferoffset is the starting offset of the buffer, and size is the number of bytes to copy.',
  copybuffertoscratchpad: 'Copies a part of the buffer to the scratchpad. The format is `copybuffertoscratchpad bufferoffset scratchoffset size`, where bufferoffset is the starting offset of the buffer, scratchoffset is the starting offset of the scratchpad, and size is the number of bytes to copy.',
  printscratchpad: 'Print the scratchpad to the screen. The format and use is the same as the `printbuffer` command.',
  setscratchpad: 'Manually set the scratchpad contents. The format and use is the same as the `setbuffer` command. The scratchpad is a second buffer that you can use. The difference between the buffer and scratchpad is that the scratchpad is not used for direct disk command data transfers. It is just for storing and manipulating any data you wish. The lines following the `setscratchpad` command are the actual data, to be ended by the `endscratchpad` command.',
  endscratchpad: 'Ends multi-line scratchpad input mode.',
  stringtoscratchpad: 'Puts a string into the scratchpad contents. The format and use is the same as the `stringtobuffer` command.',
  clearscratchpad: 'Clears (erases) the entire scratchpad contents to zeros.',
  variablecheck: 'Check if a variable has been set and what type it is. The format is `variablecheck $variable`, where `$variable` is the name of the variable to be checked. The purpose of this is to check if a variable was set properly on the command line. The result is returned in `$error_level`. A value of 0 means the variable was not set. A value of 1 means the variable is of number type but only set in script. A value of 2 means the variable is of string type but only set in script. A value of 17 means the variable is of number type and is set on the command line. A value of 18 means the variable is of string type and is set on the command line.',
  getfilesize: 'Get the size of a file. The format is `getfilesize filename`, where filename is the name (with optional path) of the file. Filename can be the raw file name or a string that contains the file name. The raw file name cannot contain spaces. If there are spaces, the file name must be in a string. The size of the file in bytes is returned in `$error_level`. If the file does not exist or there is some other error then `$error_level` will contain `-1`.',
  deletefile: 'Delete a file. The format is `deletefile filename`, where filename is the name (with optional path) of the file. Filename can be the raw file name or a string that contains the file name. The raw file name cannot contain spaces. If there are spaces, the file name must be in a string.',
  callcommand: 'Perform a command line command. The format is `callcommand command`, where command is the command line command to be performed. The command can be a string variable, or a single word command. For commands that contain multiple words, you must use a string variable.',
  userinput: 'Get user input from keyboard. The format is `userinput variable`, where variable is the string variable where the user input is placed. This will pause the program waiting for the user to type something and then press enter.',
  wordflipbuffer: 'Flip the bytes within words from little endian to normal. The format is `wordflipbuffer offset size`, where offset is the offset in the buffer to start the flip and size is how many bytes to flip. If the size is an odd number the last byte will not be flipped. This command is useful for getting some proper readable information from the identify device command, such as the model and serial number.',
  wordflipscratchpad: 'Flip the bytes within words from little endian to normal. The format and use is the same as the `wordflipbuffer` command.',
  getstatus: 'This will update the status and error registers (`$ata_return_error`, `$ata_return_status`, and `$ata_alternate_status`). This only works for direct IO. For passthrough it attempts to send the proper protocol, but it would appear that Linux does not support that protocol and returns sense data of "invalid field in CDB".',
  softreset: 'This performs a soft reset of the device. Note that this will reset both devices on the controller. This only works for direct IO. For passthrough it attempts to send the proper protocol, but it would appear that Linux does not support that protocol and returns sense data of "invalid field in CDB". To perform a soft reset using passthrough, use the `reopendisk` command.',
  usleep: 'Sleep for x amount of microseconds. The format is `usleep microseconds`. This is a way to make the program sleep without using CPU, perhaps waiting for a drive to become ready.',
  softtimeout: 'Only for direct IO, has no effect with passthrough. When performing an ATA command, the time to wait before sending a soft reset. The format is `softtimeout microseconds`. The default is `15000000 (15s)`. This is used to automatically perform a soft reset if a command times out, so that it does not have to be done manually. If this happens, the register status will reflect the status after the soft reset. The soft reset waits for the drive to be ready up to the value of `resettimeout` after performing the reset before returning. If you don’t want to perform a soft reset when it times out, set the `softtimeout` value greater than the value of `generaltimeout`.',
  resettimeout: 'Only for direct IO, has no effect with passthrough. When performing an ATA command, the time to wait for the drive to be ready after a soft reset before returning. The format is `resettimeout microseconds`. The default is `15000000 (15s)`.',
  busytimeout: 'Only for direct IO, has no effect with passthrough. When performing an ATA command, the time to wait before giving up if the device is busy prior to issuing the command. The format is `busytimeout microseconds`. The default is `15000000 (15s)`. If you don’t want the device to time out for being busy, set this value greater than the value of `generaltimeout`.',
  generaltimeout: 'This timer is mostly for direct IO, but can also influence passthrough in some circumstances. When performing a command, the time to wait before giving up if the command has not finished. The format is `generaltimeout microseconds`. The default is `30000000 (30s)`.',
  hardtimeout: 'Only for direct IO, has no effect with passthrough. When performing an ATA command, the time to wait before sending a hard reset. The format is `hardtimeout microseconds`.',
  gettime: 'This gets the current time and date and sets two variables. Number variable `$time` will have the time in microseconds since the Epoch (1970-01-01 00:00:00 +0000 (UTC)). String variable `$date` will contain the current date and time.',
  reopendisk: 'Only for passthrough, has no effect with direct IO. Closes and reopens the current disk. This seems to perform a soft reset on the drive, which can be helpful in certain cases where it may not respond properly after performing certain commands.',
  include: 'This will append another script file to the end (bottom) the current one in memory. The format is `include script`, where script is the script file to be loaded. This is useful for including common subroutines without having to copy them into every script.',
  loadscript: 'Loads a different script into memory. The format is `loadscript script`, where script is the script file to be loaded. This is mostly designed for a menu driven system. All current variables will be passed on to the new script. The new script will start from the beginning.',
  previousscript: 'Loads the previous script into memory, if there was one. This is designed for a menu driven system. When returning to the previous script, the previous script will start from the beginning. All current varaibles will be passed on to the previous script.',
  upline: 'Used for display purposes. Move the cursor up one line. This is useful for repeating data on the screen without scrolling.'
};

const SCRIPT_REFERENCE_BASE_URL = 'https://github.com/ISpillMyDrink/OpenSuperClone/wiki/Script-Reference';
const BUILTIN_FUNCTION_LINKS = Object.fromEntries(
  Object.keys(BUILTIN_FUNCTION_DOCS).map((name) => [name, `${SCRIPT_REFERENCE_BASE_URL}#${name}`])
);
const DEFAULT_VARIABLES_LINK = `${SCRIPT_REFERENCE_BASE_URL}#default-variables`;

const BUILTIN_VARIABLES = new Set(Object.keys(BUILTIN_VARIABLE_DOCS));

const BLOCK_OPENERS = {
  if: 'endif',
  while: 'done',
  subroutine: 'endsubroutine',
  setbuffer: 'endbuffer',
  setscratchpad: 'endscratchpad'
};

const BLOCK_CLOSERS = new Set(['endif', 'done', 'endsubroutine', 'endbuffer', 'endscratchpad']);

module.exports = {
  BLOCK_CLOSERS,
  BLOCK_OPENERS,
  BUILTIN_FUNCTION_DOCS,
  BUILTIN_FUNCTION_LINKS,
  BUILTIN_VARIABLE_DOCS,
  CONSTANT_DOCS,
  DEFAULT_VARIABLES_LINK,
  BUILTIN_VARIABLES,
  COMMANDS,
  CONTROL_KEYWORD_DOCS,
  CONTROL_KEYWORDS,
  INCLUDE_COMMANDS
};
